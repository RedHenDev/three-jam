<!DOCTYPE html>
<html>
<head>
    <title>Gliding Cube Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let camera, scene, renderer, cube;
        let velocity = 0;
        let isFlying = false;
        const GRAVITY = 0.004;
        const THRUST_FORCE = 0.008;
        const MAX_VELOCITY = 0.2;
        const MOVE_SPEED = 0.1;
        const MAX_HEIGHT = 2;  // Maximum height is 2 units (double cube height)
        const keysPressed = {};  // Add this to track pressed keys
        let plane;  // Make plane global so we can resize it

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 0);
            camera.lookAt(0, 0, 0);
            camera.rotation.z = Math.PI;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -25;   // Match ground plane size
            directionalLight.shadow.camera.right = 25;   // Match ground plane size
            directionalLight.shadow.camera.top = 25;     // Match ground plane size
            directionalLight.shadow.camera.bottom = -25; // Match ground plane size
            directionalLight.shadow.bias = -0.001;         // Added to reduce shadow artifacts
            scene.add(directionalLight);

            // Terrain (replace the entire terrain section)
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(50, 50);
            scene.add(gridHelper);

            // Player cube
            const geometry = new THREE.BoxGeometry(1, 0.4, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            cube = new THREE.Mesh(geometry, material);
            cube.position.y = 1;
            cube.castShadow = true;
            scene.add(cube);

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onKeyDown(event) {
            keysPressed[event.code] = true;
            if (event.code === 'Space') {
                isFlying = true;
            }
            if (event.code === 'KeyF') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
        }

        function onKeyUp(event) {
            keysPressed[event.code] = false;
            if (event.code === 'Space') {
                isFlying = false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleMovement() {
            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) cube.position.x += MOVE_SPEED;
            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) cube.position.x -= MOVE_SPEED;
            if (keysPressed['ArrowUp'] || keysPressed['KeyW']) cube.position.z += MOVE_SPEED;
            if (keysPressed['ArrowDown'] || keysPressed['KeyS']) cube.position.z -= MOVE_SPEED;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Apply thrust and gravity
            if (isFlying && cube.position.y < MAX_HEIGHT) {
                velocity += THRUST_FORCE;
            }
            velocity -= GRAVITY;
            
            // Cap velocity
            velocity = Math.min(Math.max(velocity, -MAX_VELOCITY), MAX_VELOCITY);
            
            // Update position with height limit
            cube.position.y = Math.min(Math.max(cube.position.y + velocity, 1), MAX_HEIGHT);

            if (cube.position.y <= 1) {
                velocity = 0;
            }

            handleMovement();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>